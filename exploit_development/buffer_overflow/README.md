My firs exploit development through the cybermentor course "Pratical Ethical Hacking - The Complete Course" (https://academy.tcm-sec.com/p/practical-ethical-hacking-the-complete-course).
The victim machine is vulnserver (https://thegreycorner.com/vulnserver.html) and the exploit is developmented with Immunity Debbuger (https://www.immunityinc.com/products/debugger/) for check what register are filled (and what data are inside).
The type of exploit is a Buffer Overflow vulnerability.

What is BUFFER OVERFLOW?


                ANATOMY OF THE STACK 
                                                   
          ==============================              _
                      ESP                   TOP       |    
            (Extended Stack Pointer)                  |
          ==============================              |
                 Buffer space                         |
          ==============================              |
              Extended Base Pointer         BOTTOM    v
          ==============================
           Extended Instruction Pointer
          ==============================


The buffer space is where characters take place ---> in a buffer overflow attack you will continue to fill the buffer space until the maximum reach, than the EBP
and finally the EIP (the Return Address) and fill it with something that we need (like reverse shell)



How to CONDUCT OVERFLOW?

1) Spiking (find vulnerable part)
2) Fuzzing (send characters and see if you can break the vulnerable part)
3) find the Offset
4) overwrtie EIP
5) Find bad characters
6) Find the right module
7) Generate shellcode      (or malicious shell code)

_________
SPIKING
_________
Let's take a look at the avaiable command on vulnserver

![Screenshot at 2021-09-13 11-00-10](https://user-images.githubusercontent.com/50571084/133260252-c0d03243-f7b9-488a-a32a-44b3d072fdb5.png)

Ok, first thing to discovered is which command is vulnerable to overflow using simple .spk files (I've replaced [COMMAND] with a command avaiable)
```
s_readline();
s_string("[COMMAND] ");
s_string_variable("0");
```
After a try with the STATS command, the TRUN command give an error of overflow (thanks to immunity debbuger I can note this) meaning that TRUN command is vulnerable.
Now that we have our vulnerable command we can go through the next step

![Cattura](https://user-images.githubusercontent.com/50571084/133263167-32005125-e8a1-4954-a611-cc3b13eaf965.PNG)

(command for sending packet at the server)
_________
FUZZING
_________
With this steps we are going to determine (approximately) how many bytes the buffer can hold before giving an error
The script *fuzzing.py* help us with an infinite cycle start from a buffer of length 100 and at every step add other 100 characters and send it to the server.
The script continue until an error occurs giving us a response with the length that make the server crash (in my case the result was 2100).
With this info we can resume that payload with lenght >= 2100 make a overflow

![Cattura](https://user-images.githubusercontent.com/50571084/133273702-dade8133-0821-45bb-92b2-4eee45eb7213.PNG)

(proof of overflow)
_________
FIND THE OFFSET
_________
Now we are going to perform a foundamnetal step : determine the **exact** length of the offset
we need 2 important tools that will help us to achieve our objective 

**pattern_create.rb** : given a specific length it create a pattern that we will insert inside the *find_offset.py* as payload

and

**pattern_offset.rb** : given the length using for **pattern_create.rb** and the content of the EIP after running *find_offset.py* it give the exact length of the offset

![Screenshot at 2021-09-13 12-05-25](https://user-images.githubusercontent.com/50571084/133268031-d3d3bcba-1ae6-4cbb-a4a8-fb6403f3ac51.png)

![Screenshot at 2021-09-13 12-14-13](https://user-images.githubusercontent.com/50571084/133268083-85659c13-6ad9-4576-92e2-190f0992d55e.png)

the result is 2003 now we have the exact length of the buffer

_________
OVERWRITE THE EIP
_________
Now, theoricaly, we can controll the EIP filling with data that we want but before go on we need to check the theory and discovered if pratically works as we are designing.
The *overwrite.py* script is likely like previous script but the payload is different : a string of 2003 character (with is needed for fill the buffer) and a string like "BBBB" (4 characters cuz the registers conmtains 4 bytes).

Now if everything worked well after running our script we will take a look at the content of EIP and check if is 42424242 (= "BBBB" in hex)

![Cattura3](https://user-images.githubusercontent.com/50571084/133270349-b9738d9f-cb87-422e-a6f7-7831df5f61fe.png)

As we can se we can controll the EIP and we can pass to the next step.
_________
BAD CHARACTERS
_________
Another important task to solve is find **BAD CHARACTERS**.

**BAD CHARACTERS** finding is critical because this type of chars can break the shell code and our exploit wont work correctly.
```
COMMON BAD CHARS
1.\x00 for NULL
2.\x0A for Line Feed \n
3.\x0D for Carriage Return \r
4.\xFF for Form Feed \f
```

First of all we need to use the tool *badchars* (https://github.com/cytopia/badchars) for build a right payload to send to the server (bad_char.py), than when the server receive the payload using Immunity Debbuger (expecially the Hex Dump) we can take a look at how the server is reading the payload.

in this case just the \x00 is a bad char and it will break the code we will try to inject.

```
Here is an example of bad chars discovere with the Hex Dump (it's not the Hex Dump of the exploit development I've done)
```

![Cattura](https://user-images.githubusercontent.com/50571084/133274462-72c22538-0715-4818-8660-2fee77d4e414.PNG)

```
As you can se the highlighted bytes are "corrupted" meaning that some specific bytes are BAD CHARACTERS 
(on consecutive corrupted bytes you just need to take care of the first one as bad character like the 04 and 05 bytes are both corrupted but just the 04 is a bad character)
```
_________
FIND THE RIGHT MODULE
_________
In this step we are going to search (and find) parts of the application that doesn't have any sort of memory protection (such as ASLR, DEP, SafeSEH, ecc..) so we can use that parts for our exploit

we need to use Mona (a python programm) unite to Immunity Debbuger, allowing us with some simple commands to find the right module to work to.

```
!mona modules ---> take a look at all the modules with their protection (TRUE/FALSE)
```
![Cattura4](https://user-images.githubusercontent.com/50571084/133277171-5b23bfc8-3998-4669-a3fb-c6b92221ad93.PNG)

The highlighted line show us that the essfunc.dll doesnt have any protection enabled. This is a right module

Now before we go on we need to translate the assembly command **JMP ESP** in hex, we can use a metasploit command for this task

![Cattura](https://user-images.githubusercontent.com/50571084/133319909-7006258d-efe1-4045-a2e6-ae2d92166fc4.PNG)

```
Why is JMP ESP important?
JMP ESP jump to the next address on the overflow buffer (where the shellcode will be located) 
```

Next, we have found the right module and we have the hex code of the **JMP ESP** command (\xff\xe4) so we need to find (inside the module) the address of when **JMP ESP** is invoked so we can use that for run our shellcode.

For this task mona come to help us again 

```
!mona find -s "[HEX STRING]" -m [MODULE] ---> given a module (-m) return address(es) of the specific command in hex (-s)
```

![Cattura5](https://user-images.githubusercontent.com/50571084/133320865-778defa5-8109-4985-834a-33d52f7d3964.PNG)

As we can see *625011af* is the address we wanted to.

For finish this step I checked if the EIP is filled correctly so in the *right_module.py* script after the buffer we are going to put the address *625011af*.

Before run the script we are going to set a breakpoint on the *625011af* address,so we are going to stop the programm when that address is accessed and we can confirm the reliabilty of the script.

This is the result after running the script (SUCCESS!) 

![Cattura7](https://user-images.githubusercontent.com/50571084/133322420-a87186a9-a511-4470-bee3-a197103c3b8e.PNG)

Now that we can have access at the **JMP ESP** command we can exploit this for let the victim machine run every code we put after the buffer payload
_________
GENERATE SHELLCODE
_________

We have setup everything that we need to go through (badchars,right module and gain access to the EIP) now we just need to create a reverse shell (in hex) for let the victim machine connect to us.

Another metasploit tools called **msfvenom** can come handly

![Screenshot at 2021-09-14 11-25-05](https://user-images.githubusercontent.com/50571084/133323237-2aba66e8-0044-481d-a480-ddc2492d8c29.png)

```
-p ---> type of shell (in this case a reverse shell)
-f ---> format of the output (c,python,java,ecc...)
-a ---> type of architecture (in this case x86)
-b ---> a bad char (in this case \x00, this is why bad chars are important cuz in case we didn't discovered it the shell will not work)
```
Finally our exploit is ready **shellcode.py**, but before check the result we need to add a padding (that can be variable, exploit development is also try different length of the padding) otherwise if padding is not present the shellcode won't work.

Obviously we need to open a netcat listener before running the script, than we can run the script and enjoy our shell

![Screenshot at 2021-09-14 12-44-45](https://user-images.githubusercontent.com/50571084/133325041-82a692e8-51f4-41f6-a51b-a9cc366d7772.png)

with this we cheked that our first exploit development worked!!
