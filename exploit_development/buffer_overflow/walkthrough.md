My firs exploit development through the cybermentor course "Pratical Ethical Hacking - The Complete Course" (https://academy.tcm-sec.com/p/practical-ethical-hacking-the-complete-course).
The victim machine is vulnserver (https://thegreycorner.com/vulnserver.html) and the exploit is developmented with Immunity Debbuger (https://www.immunityinc.com/products/debugger/) for check what register are filled (and what data are inside).
The type of exploit is a Buffer Overflow vulnerability.

What is BUFFER OVERFLOW?


                ANATOMY OF THE STACK 
                                                   
          ==============================              _
                      ESP                   TOP       |    
            (Extended Stack Pointer)                  |
          ==============================              |
                 Buffer space                         |
          ==============================              |
              Extended Base Pointer         BOTTOM    v
          ==============================
           Extended Instruction Pointer
          ==============================


The buffer space is where characters take place ---> in a buffer overflow attack you will continue to fill the buffer space until the maximum reach, than the EBP
and finally the EIP (the Return Address) and fill it with something that we need (like reverse shell)



How to CONDUCT OVERFLOW?

1) Spiking (find vulnerable part)
2) Fuzzing (send characters and see if you can break the vulnerable part)
3) find the Offset
4) overwrtie EIP
5) Find bad characters
6) Find the right module
7) Generate shellcode      (or malicious shell code)

_________
SPIKING
_________
Let's take a look at the avaiable command on vulnserver

![Screenshot at 2021-09-13 11-00-10](https://user-images.githubusercontent.com/50571084/133260252-c0d03243-f7b9-488a-a32a-44b3d072fdb5.png)

Ok, first thing to discovered is which command is vulnerable to overflow using simple .spk files (I've replaced [COMMAND] with a command avaiable)
```
s_readline();
s_string("[COMMAND] ");
s_string_variable("0");
```
After a try with the STATS command, the TRUN command give an error of overflow (thanks to immunity debbuger I can note this) meaning that TRUN command is vulnerable.
Now that we have our vulnerable command we can go through the next step

![Cattura](https://user-images.githubusercontent.com/50571084/133263167-32005125-e8a1-4954-a611-cc3b13eaf965.PNG)

(command for sending packet at the server)
_________
FUZZING
_________
With this steps we are going to determine (approximately) how many bytes the buffer can hold before giving an error
The script *fuzzing.py* help us with an infinite cycle start from a buffer of length 100 and at every step add other 100 characters and send it to the server.
The script continue until an error occurs giving us a response with the length that make the server crash (in my case the result was 2100).
With this info we can resume that payload with lenght >= 2100 make a overflow

![Cattura](https://user-images.githubusercontent.com/50571084/133273702-dade8133-0821-45bb-92b2-4eee45eb7213.PNG)

(proof of overflow)
_________
FIND THE OFFSET
_________
Now we are going to perform a foundamnetal step : determine the **exact** length of the offset
we need 2 important tools that will help us to achieve our objective 

**pattern_create.rb** : given a specific length it create a pattern that we will insert inside the *find_offset.py* as payload

and

**pattern_offset.rb** : given the length using for **pattern_create.rb** and the content of the EIP after running *find_offset.py* it give the exact length of the offset

![Screenshot at 2021-09-13 12-05-25](https://user-images.githubusercontent.com/50571084/133268031-d3d3bcba-1ae6-4cbb-a4a8-fb6403f3ac51.png)

![Screenshot at 2021-09-13 12-14-13](https://user-images.githubusercontent.com/50571084/133268083-85659c13-6ad9-4576-92e2-190f0992d55e.png)

the result is 2003 now we have the exact length of the buffer

_________
OVERWRITE THE EIP
_________
Now, theoricaly, we can controll the EIP filling with data that we want but before go on we need to check the theory and discovered if pratically works as we are designing.
The *overwrite.py* script is likely like previous script but the payload is different : a string of 2003 character (with is needed for fill the buffer) and a string like "BBBB" (4 characters cuz the registers conmtains 4 bytes).

Now if everything worked well after running our script we will take a look at the content of EIP and check if is 42424242 (= "BBBB" in hex)

![Cattura3](https://user-images.githubusercontent.com/50571084/133270349-b9738d9f-cb87-422e-a6f7-7831df5f61fe.png)

As we can se we can controll the EIP and we can pass to the next step.
_________
BAD CHARACTERS
_________
Another important task to solve is find **BAD CHARACTERS**.

**BAD CHARACTERS** finding is critical because this type of chars can break the shell code and our exploit wont work correctly.
```
COMMON BAD CHARS
1.\x00 for NULL
2.\x0A for Line Feed \n
3.\x0D for Carriage Return \r
4.\xFF for Form Feed \f
```

First of all we need to use the tool *badchars* (https://github.com/cytopia/badchars) for build a right payload to send to the server (bad_char.py), than when the server receive the payload using Immunity Debbuger (expecially the Hex Dump) we can take a look at how the server is reading the payload.

in this case just the \x00 is a bad char and it will break the code we will try to inject.

```
Here is an example of bad chars discovere with the Hex Dump (it's not the Hex Dump of the exploit development I've done)
```

![Cattura](https://user-images.githubusercontent.com/50571084/133274462-72c22538-0715-4818-8660-2fee77d4e414.PNG)

```
As you can se the highlighted bytes are "corrupted" meaning that some specific bytes are BAD CHARACTERS 
(on consecutive corrupted bytes you just need to take care of the first one as bad character like the 04 and 05 bytes are both corrupted but just the 04 is a bad character)
```
_________
FIND THE RIGHT MODULE
_________
In this step we are going to search (and find) parts of the application that doesn't have any sort of memory protection (such as ASLR, DEP, SafeSEH, ecc..) so we can use that parts for our exploit

we need to use Mona (a python programm) unite to Immunity Debbuger, allowing us with some simple commands to find the right module to work to.

```
!mona modules ---> take a look at all the modules with their protection (TRUE/FALSE)
```
![Cattura4](https://user-images.githubusercontent.com/50571084/133277171-5b23bfc8-3998-4669-a3fb-c6b92221ad93.PNG)

The highlighted line show us that the essfunc.dll doesnt have any protection enabled. This is a right module

